/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.9 2005/01/07 09:37:18 dts12 Exp $
 */
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "twrmond.h"
#include "rmon.h"
#include "rmonTable.h"

extern u_int32_t nProtocoDirLastChange;
extern u_int32_t nAddrMapIns;
extern u_int32_t nAddrMapDel;
extern u_int32_t nAddrMapMaxDE;
int32_t nProbeReset = 1;
/*
 SYNTAX	BITS {
etherStats(0), historyControl(1), etherHistory(2), alarm(3), F
hosts(4)     , hostTopN(5)     , matrix(6)      , filter(7), A
capture(8)   , event(9)        , tokenRingMLStats(10),  tokenRingPStats(11), 4
tokenRingMLHistory(12), tokenRingPHistory(13), ringStation(14), ringStationOrder(15), 0
ringStationConfig(16), sourceRouting(17),  protocolDirectory(18), protocolDistribution(19),3
addressMapping(20), nlHost(21),  nlMatrix(22), alHost(23),F
alMatrix(24), usrHistory(25), probeConfig(26) 8
*/
u_char szProbeCap[] = {0xfa, 0x40, 0x3f, 0x80};

u_char szSmonCap[] = {0x00};

/*
 -- FROM	HC-RMON-MIB
  SYNTAX	BITS {mediaIndependentGroup(0), etherStatsHighCapacityGroup(1),
      etherHistoryHighCapacityGroup(2), hostHighCapacityGroup(3),
      hostTopNHighCapacityGroup(4), matrixHighCapacityGroup(5),
      captureBufferHighCapacityGroup(6), protocolDistributionHighCapacityGroup(7),
      nlHostHighCapacityGroup(8), nlMatrixHighCapacityGroup(9),
      nlMatrixTopNHighCapacityGroup(10), alHostHighCapacityGroup(11),
      alMatrixHighCapacityGroup(12), alMatrixTopNHighCapacityGroup(13),
      usrHistoryHighCapacityGroup(14)}
*/
u_char szHCCap[] = {0x60, 0x00};
u_char szHCACap[] = {0x00};
u_char szSoftRev[] = "TWRMON RMON1/2 Agent 1.0.0";
u_char szHardRev[] = "TWRMON";
u_char szProbeDateTime[8];

static u_int32_t nDefGW = 0;

/** Initializes the rmon module */
void init_rmon(void)
{
  static oid protocolDirLastChange_oid[] = {1, 3, 6, 1, 2, 1, 16, 11, 1};
  static oid addressMapInserts_oid[] = {1, 3, 6, 1, 2, 1, 16, 13, 1};
  static oid addressMapDeletes_oid[] = {1, 3, 6, 1, 2, 1, 16, 13, 2};
  static oid addressMapMaxDesiredEntries_oid[] = {1, 3, 6, 1, 2, 1, 16, 13, 3};
  static oid probeCapabilities_oid[] = {1, 3, 6, 1, 2, 1, 16, 19, 1};
  static oid probeSoftwareRev_oid[] = {1, 3, 6, 1, 2, 1, 16, 19, 2};
  static oid probeHardwareRev_oid[] = {1, 3, 6, 1, 2, 1, 16, 19, 3};
  static oid probeDateTime_oid[] = {1, 3, 6, 1, 2, 1, 16, 19, 4};
  static oid probeResetControl_oid[] = {1, 3, 6, 1, 2, 1, 16, 19, 5};
  static oid probeDownloadFile_oid[] = {1, 3, 6, 1, 2, 1, 16, 19, 6};
  static oid probeDownloadTFTPServer_oid[] = {1, 3, 6, 1, 2, 1, 16, 19, 7};
  static oid probeDownloadAction_oid[] = {1, 3, 6, 1, 2, 1, 16, 19, 8};
  static oid probeDownloadStatus_oid[] = {1, 3, 6, 1, 2, 1, 16, 19, 9};
  static oid netDefaultGateway_oid[] = {1, 3, 6, 1, 2, 1, 16, 19, 12};
  static oid smonCapabilities_oid[] = {1, 3, 6, 1, 2, 1, 16, 19, 15};
  static oid hcRMONCapabilities_oid[] = {1, 3, 6, 1, 2, 1, 16, 19, 16};
  static oid hcAlarmCapabilities_oid[] = {1, 3, 6, 1, 2, 1, 16, 29, 1, 2, 1};

  DEBUGMSGTL(("rmon", "Initializing\n"));

  netsnmp_register_scalar(
      netsnmp_create_handler_registration("protocolDirLastChange", handle_protocolDirLastChange,
                                          protocolDirLastChange_oid, OID_LENGTH(protocolDirLastChange_oid),
                                          HANDLER_CAN_RONLY));
  netsnmp_register_scalar(
      netsnmp_create_handler_registration("addressMapInserts", handle_addressMapInserts,
                                          addressMapInserts_oid, OID_LENGTH(addressMapInserts_oid),
                                          HANDLER_CAN_RONLY));
  netsnmp_register_scalar(
      netsnmp_create_handler_registration("addressMapDeletes", handle_addressMapDeletes,
                                          addressMapDeletes_oid, OID_LENGTH(addressMapDeletes_oid),
                                          HANDLER_CAN_RONLY));
  netsnmp_register_scalar(
      netsnmp_create_handler_registration("addressMapMaxDesiredEntries", handle_addressMapMaxDesiredEntries,
                                          addressMapMaxDesiredEntries_oid, OID_LENGTH(addressMapMaxDesiredEntries_oid),
                                          HANDLER_CAN_RWRITE));
  netsnmp_register_scalar(
      netsnmp_create_handler_registration("probeCapabilities", handle_probeCapabilities,
                                          probeCapabilities_oid, OID_LENGTH(probeCapabilities_oid),
                                          HANDLER_CAN_RONLY));
  netsnmp_register_scalar(
      netsnmp_create_handler_registration("probeSoftwareRev", handle_probeSoftwareRev,
                                          probeSoftwareRev_oid, OID_LENGTH(probeSoftwareRev_oid),
                                          HANDLER_CAN_RONLY));
  netsnmp_register_scalar(
      netsnmp_create_handler_registration("probeHardwareRev", handle_probeHardwareRev,
                                          probeHardwareRev_oid, OID_LENGTH(probeHardwareRev_oid),
                                          HANDLER_CAN_RONLY));
  netsnmp_register_scalar(
      netsnmp_create_handler_registration("probeDateTime", handle_probeDateTime,
                                          probeDateTime_oid, OID_LENGTH(probeDateTime_oid),
                                          HANDLER_CAN_RWRITE));
  netsnmp_register_scalar(
      netsnmp_create_handler_registration("probeResetControl", handle_probeResetControl,
                                          probeResetControl_oid, OID_LENGTH(probeResetControl_oid),
                                          HANDLER_CAN_RWRITE));
  netsnmp_register_scalar(
      netsnmp_create_handler_registration("probeDownloadFile", handle_probeDownloadFile,
                                          probeDownloadFile_oid, OID_LENGTH(probeDownloadFile_oid),
                                          HANDLER_CAN_RWRITE));
  netsnmp_register_scalar(
      netsnmp_create_handler_registration("probeDownloadTFTPServer", handle_probeDownloadTFTPServer,
                                          probeDownloadTFTPServer_oid, OID_LENGTH(probeDownloadTFTPServer_oid),
                                          HANDLER_CAN_RWRITE));
  netsnmp_register_scalar(
      netsnmp_create_handler_registration("probeDownloadAction", handle_probeDownloadAction,
                                          probeDownloadAction_oid, OID_LENGTH(probeDownloadAction_oid),
                                          HANDLER_CAN_RWRITE));
  netsnmp_register_scalar(
      netsnmp_create_handler_registration("probeDownloadStatus", handle_probeDownloadStatus,
                                          probeDownloadStatus_oid, OID_LENGTH(probeDownloadStatus_oid),
                                          HANDLER_CAN_RONLY));
  netsnmp_register_scalar(
      netsnmp_create_handler_registration("netDefaultGateway", handle_netDefaultGateway,
                                          netDefaultGateway_oid, OID_LENGTH(netDefaultGateway_oid),
                                          HANDLER_CAN_RWRITE));
  netsnmp_register_scalar(
      netsnmp_create_handler_registration("smonCapabilities", handle_smonCapabilities,
                                          smonCapabilities_oid, OID_LENGTH(smonCapabilities_oid),
                                          HANDLER_CAN_RONLY));
  netsnmp_register_scalar(
      netsnmp_create_handler_registration("hcRMONCapabilities", handle_hcRMONCapabilities,
                                          hcRMONCapabilities_oid, OID_LENGTH(hcRMONCapabilities_oid),
                                          HANDLER_CAN_RONLY));
  netsnmp_register_scalar(
      netsnmp_create_handler_registration("hcAlarmCapabilities", handle_hcAlarmCapabilities,
                                          hcAlarmCapabilities_oid, OID_LENGTH(hcAlarmCapabilities_oid),
                                          HANDLER_CAN_RONLY));
}

int handle_protocolDirLastChange(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    snmp_set_var_typed_value(requests->requestvb, ASN_TIMETICKS, (u_char *)&nProtocoDirLastChange, sizeof(u_int32_t));
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_protocolDirLastChange\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}
int handle_addressMapInserts(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&nAddrMapIns, sizeof(u_int32_t));
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_addressMapInserts\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}
int handle_addressMapDeletes(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&nAddrMapDel, sizeof(u_int32_t));
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_addressMapDeletes\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}
int handle_addressMapMaxDesiredEntries(netsnmp_mib_handler *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info *reqinfo,
                                       netsnmp_request_info *requests)
{
  int ret;
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&nAddrMapMaxDE, sizeof(u_int32_t));
    break;

  /*
   * SET REQUEST
   *
   * multiple states in the transaction.  See:
   * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
   */
  case MODE_SET_RESERVE1:
    /* or you could use netsnmp_check_vb_type_and_size instead */
    ret = netsnmp_check_vb_int_range(requests->requestvb, 100, 20000);
    if (ret != SNMP_ERR_NOERROR)
    {
      netsnmp_set_request_error(reqinfo, requests, ret);
    }
    break;

  case MODE_SET_RESERVE2:
    break;

  case MODE_SET_FREE:
    break;

  case MODE_SET_ACTION:
    break;

  case MODE_SET_COMMIT:
    nAddrMapMaxDE = (u_int32_t)requests->requestvb->val.integer;
    break;

  case MODE_SET_UNDO:
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_addressMapMaxDesiredEntries\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}
int handle_probeCapabilities(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)szProbeCap, sizeof(szProbeCap));
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_probeCapabilities\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}
int handle_probeSoftwareRev(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)szSoftRev, strlen(szSoftRev));
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_probeSoftwareRev\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}
int handle_probeHardwareRev(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)szHardRev, strlen(szHardRev));
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_probeHardwareRev\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}

static void SetProbeDateTime(void)
{
  struct timeval t;
  struct timezone tz;
  struct tm *pTm;
  int nTmp;
  gettimeofday(&t, &tz);
  pTm = localtime(&t.tv_sec);
  nTmp = pTm->tm_year;

  szProbeDateTime[0] = (u_char)(nTmp >> 8);
  szProbeDateTime[1] = (u_char)(nTmp & 0x00ff);
  szProbeDateTime[2] = (u_char)(pTm->tm_mon + 1);
  szProbeDateTime[3] = (u_char)(pTm->tm_mday);
  szProbeDateTime[4] = (u_char)(pTm->tm_hour);
  szProbeDateTime[5] = (u_char)(pTm->tm_min);
  szProbeDateTime[6] = (u_char)(pTm->tm_sec);
  nTmp = t.tv_usec;
  nTmp /= 1000;
  nTmp /= 100;
  szProbeDateTime[7] = (u_char)(nTmp); // 0.1 Sec
  return;
}
int handle_probeDateTime(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
  int ret;
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    SetProbeDateTime();
    snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)szProbeDateTime, sizeof(szProbeDateTime));
    break;

  /*
   * SET REQUEST
   *
   * multiple states in the transaction.  See:
   * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
   */
  case MODE_SET_RESERVE1:
    /* or you could use netsnmp_check_vb_type_and_size instead */
    //            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
    ret = SNMP_ERR_NOTWRITABLE;
    if (ret != SNMP_ERR_NOERROR)
    {
      netsnmp_set_request_error(reqinfo, requests, ret);
    }
    break;

  case MODE_SET_RESERVE2:
    break;

  case MODE_SET_FREE:
    break;

  case MODE_SET_ACTION:
    break;

  case MODE_SET_COMMIT:
    break;

  case MODE_SET_UNDO:
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_probeDateTime\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}
int handle_probeResetControl(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
  int ret;
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&nProbeReset, sizeof(int32_t));
    break;

  /*
   * SET REQUEST
   *
   * multiple states in the transaction.  See:
   * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
   */
  case MODE_SET_RESERVE1:
    /* or you could use netsnmp_check_vb_type_and_size instead */
    ret = netsnmp_check_vb_int_range(requests->requestvb, 2, 3);
    if (ret != SNMP_ERR_NOERROR)
    {
      netsnmp_set_request_error(reqinfo, requests, ret);
    }
    break;

  case MODE_SET_RESERVE2:
    break;

  case MODE_SET_FREE:
    break;

  case MODE_SET_ACTION:
    break;

  case MODE_SET_COMMIT:
    nProbeReset = (int32_t)requests->requestvb->val.integer;
    ResetRmonTable();
    break;

  case MODE_SET_UNDO:
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_probeResetControl\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}
int handle_probeDownloadFile(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
  int ret;
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)"", 0);
    break;

  /*
   * SET REQUEST
   *
   * multiple states in the transaction.  See:
   * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
   */
  case MODE_SET_RESERVE1:
    /* or you could use netsnmp_check_vb_type_and_size instead */
    //           ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
    ret = SNMP_ERR_NOTWRITABLE;
    if (ret != SNMP_ERR_NOERROR)
    {
      netsnmp_set_request_error(reqinfo, requests, ret);
    }
    break;

  case MODE_SET_RESERVE2:
    break;

  case MODE_SET_FREE:
    break;

  case MODE_SET_ACTION:
    break;

  case MODE_SET_COMMIT:
    break;

  case MODE_SET_UNDO:
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_probeDownloadFile\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}
int handle_probeDownloadTFTPServer(netsnmp_mib_handler *handler,
                                   netsnmp_handler_registration *reginfo,
                                   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests)
{
  int ret;
  static char pEIP[4] = {0, 0, 0, 0}; // YMI Fix 2007.8.21
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *)pEIP, 4); // YMI Fix
    break;

  /*
   * SET REQUEST
   *
   * multiple states in the transaction.  See:
   * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
   */
  case MODE_SET_RESERVE1:
    /* or you could use netsnmp_check_vb_type_and_size instead */
    //            ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
    ret = SNMP_ERR_NOTWRITABLE;
    if (ret != SNMP_ERR_NOERROR)
    {
      netsnmp_set_request_error(reqinfo, requests, ret);
    }
    break;

  case MODE_SET_RESERVE2:
    break;

  case MODE_SET_FREE:
    break;

  case MODE_SET_ACTION:
    break;

  case MODE_SET_COMMIT:
    break;

  case MODE_SET_UNDO:
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_probeDownloadTFTPServer\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}
int handle_probeDownloadAction(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
  int ret;
  static int32_t nDA = 1;
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&nDA, sizeof(int32_t));
    break;

  /*
   * SET REQUEST
   *
   * multiple states in the transaction.  See:
   * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
   */
  case MODE_SET_RESERVE1:
    /* or you could use netsnmp_check_vb_type_and_size instead */
    //            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
    ret = SNMP_ERR_NOTWRITABLE;
    if (ret != SNMP_ERR_NOERROR)
    {
      netsnmp_set_request_error(reqinfo, requests, ret);
    }
    break;

  case MODE_SET_RESERVE2:
    break;

  case MODE_SET_FREE:
    break;

  case MODE_SET_ACTION:
    break;

  case MODE_SET_COMMIT:
    break;

  case MODE_SET_UNDO:
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_probeDownloadAction\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}
int handle_probeDownloadStatus(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
  static int32_t nDS = 2;
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&nDS, sizeof(int32_t));
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_probeDownloadStatus\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}

static void GetDefGw(void)
{
  FILE *fp;
  char szLine[1024];
  char szTmp[64];
  char szDefGW[64];
  int c;
  nDefGW = 0;
  fp = popen("route", "r");
  if (fp == NULL)
    return;
  while (fgets(szLine, sizeof(szLine), fp))
  {
    char *p = strstr(szLine, "default");
    if (p == NULL)
      continue;
    p += strlen("default");
    c = sscanf(p, "%s %s", szTmp, szDefGW);
    if (c != 2)
      continue;
    nDefGW = inet_addr(szDefGW);
    break;
  }
  pclose(fp);
  return;
}

int handle_netDefaultGateway(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
  int ret;
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    GetDefGw();
    snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *)&nDefGW, sizeof(int32_t));
    break;

  /*
   * SET REQUEST
   *
   * multiple states in the transaction.  See:
   * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
   */
  case MODE_SET_RESERVE1:
    /* or you could use netsnmp_check_vb_type_and_size instead */
    //            ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
    ret = SNMP_ERR_NOTWRITABLE;
    if (ret != SNMP_ERR_NOERROR)
    {
      netsnmp_set_request_error(reqinfo, requests, ret);
    }
    break;

  case MODE_SET_RESERVE2:
    break;

  case MODE_SET_FREE:
    break;

  case MODE_SET_ACTION:
    break;

  case MODE_SET_COMMIT:
    break;

  case MODE_SET_UNDO:
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_netDefaultGateway\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}
int handle_smonCapabilities(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)szSmonCap, sizeof(szSmonCap));
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_smonCapabilities\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}
int handle_hcRMONCapabilities(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)szHCCap, sizeof(szHCCap));
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_hcRMONCapabilities\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}
int handle_hcAlarmCapabilities(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
  /* We are never called for a GETNEXT if it's registered as a
     "instance", as it's "magically" handled for us.  */

  /* a instance handler also only hands us one request at a time, so
     we don't need to loop over a list of requests; we'll only get one. */

  switch (reqinfo->mode)
  {

  case MODE_GET:
    snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)szHCACap, sizeof(szHCACap));
    break;

  default:
    /* we should never get here, so this is a really bad error */
    snmp_log(LOG_ERR, "unknown mode (%d) in handle_hcAlarmCapabilities\n", reqinfo->mode);
    return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}
